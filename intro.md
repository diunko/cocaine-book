
# Intro

## Actor Model

actors bla actors bla over actors

## Messages, Streams, and Services

In Cocaine terms, Services are actors. Any Service has it's tcp or unix
socket. Anybody can connect to Service's socket and exchange messages
with it. Let's call any kind of established connection a channel. Within
a channel, there can be multiple conversations going between Service
and it's client, let's call such conversation a session.
Messages in a session are all of the same `session_id`. `session_id` is
generated by the initiating client uniquely for the channel.

On a protocol level, Cocaine message is a msgpack-packed object of the
following form. Here, `method_id` is a numeric identifier of the service
method being called, `session_id` uniquely identifies session within
the channel, and `args` are arguments of any form.

`method_id`s of a certain service are described in the corresponding
service protocol table and can be discovered through the Locator
service. Here, we use symbolic names `:method` to refer to  numeric id
of a method in a table of certain service.

Currently, any Service's method call looks like one `:method` message,
responded with a sequence of zero or more `:chunk`s, terminated by
`:choke` or `:error`.

Let's call stream a sequence of one or more `chunk` messages of the form
`[:chunk, <session_id>, [<binary-buffer>]]`
terminated with a `choke` message 
`[:choke, <session_id>, []]`,
which means normal stream termination, or terminated with an `error`
message
`[:error, <session_id>, [<code>, <string>]]`,
which signals some error condition for the stream. 

So, the usual method call would look like this for normal termination.

Or this, for some erroneous conditions occurred at a time of
response.


Let's say, we connect to a Locator service, which usually listens on
10053 port on some well-known host, and ask it to describe a `"node"`
service. On the wire, it would look like this.

Locator responds with. It means, that `"node"` service sits on
`some.ho.st` host `12345` port, it's protocol version is 1, and
methods are `start_app` with method_id of 0, `list` with method_id of
1, and `pause_app` with method_id of 2.

Given that, we can connect to the `node` service and call it's methods
the same way.

## Apps

Apps are actors too. The only difference is that Apps don't sit on
some listening socket, instead, after they start and initialize, they
are supposed to connect to some certain socket, and receive all
incoming requests through the resulting channel. Although, app is
exposed to the outer world using dedicated service, which proxies all
of it's messages to the app channel.

App service has method info, which. And enqueue, which. So the code
implementing app is supposed to handle somehow these events. Everybody
calls these events "handles" or "cocaine handles", and that's just
it. For instance, it makes sense to map these events to use
some exported module's methods. However, how to use or interpret them
is totally up to app/framework developer.



