
# Processes Overview

Здесь будет описано, какие происходят процессы на стадиях жизни
приложения и на стадиях обработки запроса.

## Regular Deployment Process

Деплой приложения: традиционный способ. Сборку приложения осуществляет
пользователь. На выходе процесса сборки ожидается архив с
приложением. Действие Upload архив с приложением
загружает в системный storage. Туда же загружается манифест.
По команде start приложение запускается при помощи isolate process: на
ноды кластера скачивается архив приложения, распаковывается в каталог
spool, и запускается invocation service для приложения.
Рассмотрим подробнее.

### upload
```
cocaine-tool app upload \
  --name <app-name> \
  --package path/to/app.tgz \
  --manifest manifest.json
```
Эта команда загружает бинарь приложения в сторедж, и делает его
доступным для запуска. Точнее, она делает такие две вещи. 
1. Читает манифест, запаковывает его msgpack'ом, и сохраняет в
сервис storage, по ключу manifests::<app-name> (здесь manifests -- collection, а
<app-name> - имя ключа).
1. Архив с приложением сохраняет в storage в apps::<app-name>.

Используется сконфигурированный сервис storage той ноды, на которой
выполняется команда cocaine-tool. Или тот, который указан в команде явно.

### start
```
cocaine-tool app start \
  --name <app-name> \
  --profile <profile-name>
  --host <locator-host-name|localhost>
  --port <locator-port|10053>
```
Хотя команда называется app start, фактически по этой команде
происходит деплой на ноды, а не фактический запуск воркеров
приложения. Эта команда делает одну простую вещь -- она находит сервис
`node` через заданный локатор (как правило, это локальный для заданной
ноды локатор), и у сервиса `node` вызывает метод `start_app`:
```
[start_app, <sid>, [{<app-name>:<profile-name>}]]
```
Тогда сервис node читает профиль из сервиса storage (по ключу
profiles::<profile-name>), и указанным там изолятом скачивает и
устанавливает приложение локально (это делает метод
isolate::spool). Isolate по умолчанию -- process, и 
его spool читает загруженный ранее архив приложения из
apps::<app-name> из стореджа, и распаковывает его в <spool>/<app-name>/
(<spool> берется из конфига на данной ноде).
Кроме этого, на этой ноде запускается invocation service с именем
<app-name>, а также запускается engine приложения с пустой очередью
входящих сообщений и 0 запущенных workers.

Запущенный сервис аннонсится всем клиентам locator::synchronize, и с
этого момента приложение считается запущенным.

Для того, чтобы приложение запустилось на нескольких машинках кластера,
нужно каждому сервису node на каждой из машинок отправить такой
`start_app` message.

Для того, чтобы при рестарте рантайма приложение запустилось, нужно
добавить его в runlist, сконфигурированный для данной машинки. Т.е. в
cocaine.conf должно быть написано
`{ "default-runlist": "<runlist-name>" }`, и тогда при старте
`cocaine-runtime` прочитает из стореджа `runlists::<runlist-name>`, в
котором олжидается msgpack map такого вида:
```
{ "appname1":"profile1", "appname2":"profile2", ... }
```
И для каждого приложения из этого мэпа выполняется процедура start,
как описано выше, с соответствующим профилем из мэпа.

### request handling
В invocation-service приложения входящий запрос приходит в виде 
```
[enqueue, <sid>, ["<event-name>", <binary-chunk>]]
```
Invocation-service делает из этого сообщения входящий поток для
воркера, а именно 3 таких сообщения:
```
[invoke, <sid>, ["<event-name>"]]
[chunk, <sid>, [<binary-chunk>]]
[choke, <sid>, []]
```
и пишет их в очередь воркера (вызовом метода enqueue у engine
приложения, именно поэтому метод сервиса называется enqueue).

Поток engine просыпается, выполняет метод balance, врезультате работы
которого запускается некоторое количество workers. Каждый из воркеров
запускает инстанс приложения при помощи isolate::start. Для isolate
process process::start запускает процесс, с environment из манифеста,
с working directory <spool>/<app-name>, и с аргументами командной
строки 
```
  --app <app-name> \
  --endpoint <unix-socket> \
  --locator <locator-endpoint> \
  --uuid <worker-uuid>
```

После запуска воркера engine ожидает от него соединения на сокет
`<unix-socket>`, и отправки handshake сообщения. После получения
handshake воркер считается успешно запущенным, и после первого
heartbeat сообщения от воркера engine начинает передавать ему входящие
сообщения, получать ответные потоки и проксировать их в
invocation-service, а тот приславшему клиенту.

### stop
```
cocaine-tool app stop \
  --app <app-name> \
  --host <locator-host> \ 
  --port <locator-port>
```
Эта команда отправляет `pause_app` сообщение в сервис `node`, и тот
останавливает все воркеры приложения, останавливает invocation-service
приложения, отправляет аннонсы всем клиентам locator::synchronize.

Каждый экземпляр приложения получает сообщение `terminate` от engine,
после чего в течение terminate-timeout должен завершить обработку
текущих сессий, прислать ответный `terminate` и завершиться.

Чтобы остановить приложение на нескольких машинках кластера, нужно в
сервис node на каждой машинке отправить `pause_app`. Чтобы при
рестарте `cocaine-runtime` приложение не запустилось снова, нужно
удалить его из соответствующего ранлиста.

### remove
Удаляет архив приложения из storage apps::<app-name>, удаляет манифест
из manifests::<app-name>. При этом проверки на то, запушено ли
приложение, не происходит.

### Docker isolate plugin

При использовании докер-контейнеризации (isolate::docker) код и окружение приложения
хранится в докер-репозитории. Манифест и профиль приложения играют
такую же роль, как и при isolate::process, но архив приложения не
играет значимой роли.

#### upload
По сравнению с process isolate, все шаги происходят так же. Но архив
приложения нигде, кроме upload, больше не используется, поэтому он
может быть пустым. На данный момент контейнера приложения в
докер-репозитории может еще не существовать.

#### start
На данном шаге подразумевается, что в докер-репозитории хранится
контейнер с приложением. Ппредполагается, что он каким-то образом
построен и загружен в докер-репозиторий.
Далее, все шаги происходят как в isolate::process. Отличия в
docker_isolate::spool. Вместо скачивания и распаковки архива из storage, здесь
происходит вызов docker::pull <registry>/<app-name> (подробнее см.
[docker-overview.md](docker lifecycle)), где registry
берется из профиля. После этого контейнер приложения готов к запуску
при помощи docker::start, что описывается далее.

#### handle requests
Отличия от isolate::process снова небольшие. docker_isolate::spawn
выполняет вызов docker::start, при этом монтирует в контейнер каталог
с unix-сокетом, устанавливает переменные окружения из манифеста, и
ограничения ресурсов из профиля.

#### stop, remove
Полностью аналогичны соответствующим шагам из process_isolate.


## Deployment Through ape.sh
Если в традиционном деплое cocaine-tool'ом процесс билда и слежения за
консистентностью полностью ложится на пользователя, в ape.sh делаются
некоторые минимальные проверки консистентности, билд приложения,
управления приложением.

### prerequisites
Билд приложения и весь процесс описаны более детально в
[ape-details.md](ape-details). Подразумевается, что в
докер-репозитории уже есть построенный базовый образ, внутри которого
происходит сборка приложений.

### version management notes
Управление версиями приложения происходит при помощи роутинг
групп и соглашения именования групп, приложений и версий. Группа
именуется `user_did_app`, и так же называется приожение. Версия
приложения именуется `user_did_app_at_<hash>`, где `<hash>` -- это git
хеш коммита. Следовательно, докер-образ создается с названием
`repository.host:port/user_did_app_at_<hash>`. При запуске версии
приложения в группу добавляется имя запускаемой версии приложения,
и версия становится доступна по имени `user_did_app`.

### upload
Построение docker контейнера и загрузка приложения (в смысле cocaine-tool app
upload) происходят по git push кода приложения в remote на
билд-машинке. 

1. Код приложения, полученный по git-archive  распаковывается в /app.
1. Определяется тип приложения (пока доступен только nodejs,
определяется по package.json)
1. Выполняется /build/buildpacks/<buildpack>/bin/compile над проектом.
1. Контейнер docker::push'ится в докер-репозиторий.
1. Делается cocaine-tool app upload со стандартным манифестом и
фейковым архивом
1. Добавляется роутинг-группа с именем user:appname
1. В случае успеха всех действий, git-hook prereceive возвращает
статус 0, и ref ремоута апдейтится. В случае неуспеха какого-либо из
шагов, можно исправить ошибку в проекте и сделать повторный push. Все
действия по возможности омнипотентны.

### start
```
ssh ape@host start <app-name> <treeish>
```
treeish превращается в hash коммита, и выполняются шаги:
1. На каждую ноду кластера дается команда app_start для
`<user>_<app-name>@<hash>`.
1. `<user>_<app-name>@<hash>` добавляется в ранлист.
1. `<user>_<app-name>@<hash>` добавляется в роутинг-группу
`<user>_<app-name>`.

### request handling
Здесь все обычно, кроме того, что приложение ресолвится по имени
роутинг-группы. Урл приложения http://app-name.user.apefront
превращается в `user_app-name`, и из этой роутинг группы получается
адрес одной из версий согласно весам в группе.

### stop
```
ssh ape@host stop <app-name> <treeish>
```
Выполняются шаги, обратные start.
1. `<user>_<app-name>@<hash>` удаляется из роутинг-группы
1. `<user>_<app-name>@<hash>` удаляется из ранлиста
1. `<user>_<app-name>@<hash>` останавливается на каждой ноде кластера

### remove
Выполняется такой же remove, как для process_isolate, при этом
удаление контейнера из репозитория не происходит.

## Request Handling And Balancing

### At LoadBalancer
### At Node
### At Worker

